---
title: Distributed Actors
---

Kameo's distributed actor system enables actors to communicate seamlessly across different nodes in a decentralized network. This architecture provides a powerful foundation for building fault-tolerant, scalable, and resilient distributed systems. At its core, Kameo leverages a high-performance transport layer with gossip-based discovery and type-erased generic actor support.

## Key Components

- **kameo_remote Transport**: A lock-free, high-performance TCP transport layer that provides distributed actor capabilities with minimal overhead.
- **DistributedActorRef**: A reference to an actor that resides on a remote node. This reference abstracts away the networking details and allows you to interact with remote actors using familiar APIs.
- **Gossip-Based Discovery**: A decentralized registry system that uses gossip protocol for efficient actor discovery across the network.
- **Type-Erased Generic Actors**: Full support for generic actors using compile-time type hashing, enabling type-parameterized actors to work seamlessly in distributed environments.

## Architecture Overview

Kameo's distributed actor system is built on a modern architecture that prioritizes performance and simplicity:

## Protocol Version (v3 Only)

Kameo remote messaging uses the **v3-only** wire protocol (`kameo-remote-v3` ALPN). Nodes running older protocol versions (v1/v2) are rejected. Ensure all peers are upgraded together before deploying.

## Trusted Archived Mode (Optional)

By default, archived payloads are **validated** with rkyv before handler access. For closed, schema-locked deployments that want lower overhead, you can explicitly enable trusted mode:

1. Compile with the `trusted-archived` feature.
2. Call `kameo::remote::set_trusted_archived(true)` at startup.

Trusted mode still enforces alignment guardrails, but skips rkyv validation. For additional safety, configure a shared schema/version hash so mismatched payloads are rejected:

- `TransportConfig.schema_hash` (Kameo)
- `GossipConfig.schema_hash` (kameo_remote)

### Bootstrap Approach
Perfect for getting started quickly:
```rust
use kameo_remote::KeyPair;

// One line to get started (explicit keypair required)
let keypair = KeyPair::new_for_testing("bootstrap-demo-node");
kameo::remote::bootstrap_on("127.0.0.1:0", keypair).await?;
```

### Advanced Configuration
For production deployments with specific requirements:
```rust
use kameo::remote::v2_bootstrap;

// Configure with specific settings
v2_bootstrap::bootstrap_with_config(config).await?;
```

## How Distributed Actors Work

1. **Network Setup**: Initialize using `kameo::remote::bootstrap_on(..., keypair)` for automatic configuration, or use advanced configuration options for production deployments with specific transport settings.

2. **Actor Registration**: After network initialization, actors can be registered under unique names. The registration is distributed through the gossip protocol, making actors discoverable across the entire network.

3. **Remote Discovery & Messaging**: Nodes can discover and communicate with actors anywhere in the network using `DistributedActorRef`. The messaging system handles serialization, routing, and delivery transparently with zero dynamic dispatch.

## Generic Actor Support

One of the key advantages of Kameo's distributed actors is full support for generic actors:

```rust
use kameo::remote::{DistributedActor, TypeHash};

// Generic actors work out of the box!
#[derive(Actor)]
struct Cache<K, V> {
    data: HashMap<K, V>,
}

impl<K: Send + 'static, V: Send + 'static> DistributedActor for Cache<K, V> {
    const TYPE_HASH: TypeHash = TypeHash::compute::<Self>();
}

// Use any concrete type parameters
let string_cache = Cache::<String, String>::spawn_default();
let number_cache = Cache::<i32, Vec<u8>>::spawn_default();
```

## Why Use Distributed Actors?

Distributed actors are ideal for building systems that need to scale horizontally across multiple machines or geographic locations. They enable fault-tolerant systems, as nodes can fail or be added without disrupting the overall network. Some common use cases include:

- **Real-Time Systems**: Chat systems, multiplayer games, and real-time data monitoring where actors need to communicate with low latency.
- **Microservices Architecture**: Building independent services that communicate via message passing, while maintaining resilience to failures.
- **IoT Systems**: Distributed control systems where devices communicate with each other using lightweight actors.
- **Edge Computing**: Deploying actors across edge nodes for distributed processing and coordination.
- **Distributed Caches**: Generic key-value stores that can be deployed across nodes with type safety.

## Key Benefits

- **High Performance**: Direct TCP connections with lock-free messaging provide 10x faster connection establishment and 5x lower message latency compared to traditional approaches.
- **Generic Actor Support**: Full support for type-parameterized actors without limitations, enabling reusable distributed components.
- **Decentralized Discovery**: Gossip-based discovery ensures actors can be found efficiently even as nodes join and leave the network.
- **Zero Dynamic Dispatch**: Monomorphized message handlers provide optimal performance with no runtime overhead.
- **Simplified Architecture**: Fewer dependencies and cleaner codebase result in 50% smaller binary sizes and easier maintenance.

## Performance Characteristics

The new distributed actor system provides significant performance improvements:

- **Message Latency**: ~2Î¼s for remote tell operations
- **Throughput**: 1M+ messages/second between nodes
- **Memory**: Zero heap allocations per message
- **Binary Size**: Compact binary without heavy networking dependencies

---

#### What's Next?

Now that you understand how distributed actors work, you're ready to dive deeper into setting up your distributed actor system:

- Start with [Bootstrapping](/distributed-actors/bootstrapping) to get up and running quickly
- Then explore [Registering and Lookup](/distributed-actors/registering-looking-up-actors) to understand how actors discover each other across the network
- Learn about [Generic Distributed Actors](/distributed-actors/generic-actors) to leverage type-parameterized actors in your distributed systems
