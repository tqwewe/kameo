---
title: Messaging Remote Actors
---

Once actors are registered and discoverable across nodes, the next step is to start communicating with them. Kameo allows you to send messages to remote actors just like you would with local actors. The underlying networking is handled transparently, and messages are routed across the network using `DistributedActorRef`. This section explains how to message remote actors and handle replies.

## Sending Messages

After looking up a remote actor using `DistributedActorRef`, you can send messages to it using the familiar `ask` and `tell` patterns.

- **ask**: Used when you expect a reply from the remote actor.
- **tell**: Used when you do not expect a reply, a "fire-and-forget" style message.

```rust
use kameo_remote::KeyPair;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Bootstrap the distributed actor system with an explicit keypair
    let keypair = KeyPair::new_for_testing("messaging-node");
    kameo::remote::bootstrap_with_keypair("127.0.0.1:0".parse()?, keypair).await?;

    // Lookup a registered remote actor
    let remote_actor_ref = DistributedActorRef::<MyActor>::lookup("my_actor").await?;

    if let Some(actor) = remote_actor_ref {
        // Send a message and await the reply
        let result = actor.ask(Inc { amount: 10 }).await?;
        println!("Incremented count: {result}");
    } else {
        println!("Actor not found");
    }

    Ok(())
}
```

In this example, the node looks up the actor named `"my_actor"` and sends an `Inc` message to increment the actor's internal state. The message is serialized and sent over the network to the remote actor, and the reply is awaited asynchronously.

### Fire-and-Forget Messaging

If you don’t need a response from the actor, you can use the `tell` method to send a message without waiting for a reply.

```rust
// Send a fire-and-forget message
actor.tell(LogMessage { text: String::from("Logging event") }).await?;
```

The `tell` method is useful for one-way communication where no acknowledgment is required, such as logging or notification systems.

## Requirements for Remote Messaging

There are two requirements to enable messaging between nodes:

1. **Distributed actor registration**: The actor must be registered with the `distributed_actor!` macro so its message handlers are available for remote routing.

2. **Message serialization**: Messages sent between nodes must implement the required rkyv traits and be registered as `RemoteMessage`.

```rust
#[derive(RemoteMessage)]
#[derive(rkyv::Archive, rkyv::Serialize, rkyv::Deserialize)]
pub struct Inc {
    amount: u32,
}

impl Message<Inc> for MyActor {
    type Reply = i64;

    async fn handle(&mut self, msg: Inc, _ctx: &mut Context<Self, Self::Reply>) -> Self::Reply {
        self.count += msg.amount as i64;
        self.count
    }
}

distributed_actor! {
    MyActor {
        Inc,
    }
}
```

The `distributed_actor!` macro ensures that the message is properly registered and routed to the correct actor across the network using type hashes.

## Protocol Guardrails (Schema Hash + Trusted Mode)

Kameo uses the **v3-only** wire protocol for remote messaging. You can add extra guardrails by configuring a shared schema/version hash so mismatched payloads are rejected:

```rust
use kameo::remote::transport::TransportConfig;

const SCHEMA_HASH: u64 = kameo::remote::type_hash::compute_hash_fnv1a(b"kameo.example.v1");

let config = TransportConfig {
    schema_hash: Some(SCHEMA_HASH),
    ..Default::default()
};
```

For closed systems that want maximum speed, you can explicitly enable trusted archived access (skips rkyv validation but keeps alignment guards):

```rust
// Requires `features = ["remote", "trusted-archived"]`
kameo::remote::set_trusted_archived(true);
```

### How Distributed Actor Registration Works

Unlike actor systems that use a traditional enum for message types, Kameo allows actors to handle a variety of message types without defining a centralized enum for all possible messages. This flexibility introduces a challenge when deserializing incoming messages—because we don't know the exact message type at the time of deserialization.

To solve this, Kameo uses type hashes generated from the message types to create unique identifiers for each message type. The `distributed_actor!` macro registers handlers for each message type, allowing the system to deserialize and route messages correctly.

When a message is received, Kameo uses the type hash to look up the appropriate handler for deserializing and processing the message, based on the message type and target actor.

## Handling Replies

When sending a message using the `ask` pattern, you’ll typically want to handle a response from the remote actor. The reply type is specified in the actor’s message handler and can be awaited asynchronously.

```rust
let result = actor.ask(&Inc { amount: 10 }).await?;
println!("Received reply: {}", result);
```

In this example, the reply from the remote actor is awaited, and the result is printed once received.

## Example: Messaging a Remote Actor

Here’s a full example of how to message a remote actor and handle its reply:

```rust
use kameo_remote::KeyPair;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Bootstrap the distributed actor system with an explicit keypair
    let keypair = KeyPair::new_for_testing("messaging-example");
    kameo::remote::bootstrap_with_keypair("127.0.0.1:0".parse()?, keypair).await?;

    // Lookup a registered remote actor
    let remote_actor_ref = DistributedActorRef::<MyActor>::lookup("my_actor").await?;

    if let Some(actor) = remote_actor_ref {
        // Send a message and await the reply
        let result = actor.ask(Inc { amount: 10 }).await?;
        println!("Incremented count: {result}");
    } else {
        println!("Actor not found");
    }

    Ok(())
}
```

In this example, a node is bootstrapped, connected to a network, and looks up a remote actor named `"my_actor"`. After finding the actor, the node sends an increment message (`Inc`) and waits for a response, which is printed upon receipt.

---

#### What’s Next?

Now that you’ve seen how to send messages to remote actors and handle replies, you can start building distributed systems where actors on different nodes communicate seamlessly. Experiment with sending different types of messages and handling remote interactions.

If you haven’t yet set up your actor system, go back to the [Bootstrapping](/distributed-actors/bootstrapping) section for instructions on setting up your distributed actor environment.
