---
title: Bootstrapping Distributed Actors
---

For quick development and simple distributed actor setups, Kameo provides convenient bootstrap functions that automatically configure and start a distributed actor system with sensible defaults. This approach gets you up and running with distributed actors in just one line of code.

## Quick Bootstrap

The simplest way to get started with distributed actors is using `bootstrap_with_keypair()`:

```rust
use kameo::remote;
use kameo_remote::KeyPair;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Bootstrap with automatic configuration + explicit keypair (TLS required)
    let keypair = KeyPair::new_for_testing("bootstrap-quickstart");
    remote::bootstrap_with_keypair("127.0.0.1:0".parse()?, keypair).await?;
    
    println!("Distributed actor system started");
    
    // Your actors can now be registered and discovered across the network
    Ok(())
}
```

This automatically:
- Starts a kameo_remote transport layer
- Enables gossip-based peer discovery
- Starts listening on an OS-assigned port (`0.0.0.0:0`)
- Initializes the distributed actor registry
- Sets up type-erased generic actor support

## Bootstrap on Specific Address

If you need to listen on a specific address (useful for known deployments or port requirements), use `bootstrap_on()` with a keypair:

```rust
use kameo::remote;
use kameo_remote::KeyPair;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Bootstrap listening on a specific port with an explicit keypair
    let keypair = KeyPair::new_for_testing("bootstrap-port-8020");
    remote::bootstrap_on("127.0.0.1:8020", keypair).await?;
    
    println!("Node listening on port 8020");
    Ok(())
}
```

## Complete Example

Here's a full example showing how to bootstrap and immediately start using distributed actors:

```rust
use kameo::prelude::*;
use kameo::remote;
use kameo_remote::KeyPair;

#[derive(Actor)]
struct GreeterActor;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Bootstrap the distributed actor system with an explicit keypair
    let keypair = KeyPair::new_for_testing("bootstrap-greeter");
    remote::bootstrap_with_keypair("127.0.0.1:0".parse()?, keypair).await?;
    println!("Distributed system started");
    
    // Spawn and register a local actor
    let greeter = GreeterActor::spawn_default();
    greeter.register("greeter")?;
    println!("Greeter actor registered");
    
    // Look up all greeter actors in the network
    if let Some(remote_greeter) = DistributedActorRef::<GreeterActor>::lookup("greeter").await? {
        println!("Found greeter on remote node");
    }
    
    // Keep the application running
    tokio::signal::ctrl_c().await?;
    Ok(())
}
```

## Generic Actor Example

One of the key advantages of the new system is support for generic actors:

```rust
use kameo::prelude::*;
use kameo::remote::{DistributedActor, TypeHash};
use kameo_remote::KeyPair;

#[derive(Actor)]
struct KeyValueStore<K, V> {
    data: std::collections::HashMap<K, V>,
}

impl<K: Send + 'static, V: Send + 'static> DistributedActor for KeyValueStore<K, V> {
    const TYPE_HASH: TypeHash = TypeHash::compute::<Self>();
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Bootstrap the distributed actor system with an explicit keypair
    let keypair = KeyPair::new_for_testing("bootstrap-generic");
    remote::bootstrap_with_keypair("127.0.0.1:0".parse()?, keypair).await?;
    
    // Generic actors work out of the box!
    let store = KeyValueStore::<String, i32>::spawn_default();
    store.register("number-store").await?;
    
    Ok(())
}
```

## What Bootstrap Includes

The bootstrap functions automatically configure:

- **Transport**: High-performance TCP with lock-free messaging
- **Discovery**: Gossip protocol for efficient peer discovery
- **Type System**: Compile-time type hashing for generic actors
- **Message Protocol**: Efficient binary protocol with correlation IDs
- **Actor System**: Full Kameo remote actor capabilities

## When to Use Bootstrap

Bootstrap is perfect for:
- **Development and testing** - Get started quickly without configuration
- **Simple deployments** - When default settings meet your needs
- **Prototyping** - Rapid iteration on distributed actor logic
- **Generic actors** - Full support for type-parameterized actors

## Advanced Configuration

For production deployments or specific requirements, you can configure:

- **Multiple bootstrap peers** for redundancy
- **Custom transport settings** for performance tuning
- **TLS encryption** for secure communication
- **Custom discovery mechanisms**

## Bootstrap Benefits

The modern kameo_remote-based system provides:
- **10x faster connection establishment** with optimized gossip protocol
- **5x lower message latency** with direct TCP
- **Zero dynamic dispatch** for generic actors
- **50% smaller binary size** with minimal dependencies

---

#### What's Next?

Now that your node is part of the distributed network, you can start registering actors and discovering peers. The gossip-based discovery automatically handles peer discovery, so nodes will find each other efficiently.

Continue to [Registering and Lookup](/distributed-actors/registering-looking-up-actors) to learn how to make your actors discoverable across the network.
